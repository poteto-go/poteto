package utils

import (
	"encoding/base64"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestJwtDecodeSegment(t *testing.T) {
	tests := []struct {
		name          string
		input         string
		expectedBytes []byte
		expectError   bool
		errorMsg      string
	}{
		{
			name:          "Valid Standard Base64 - No Padding Needed",
			input:         "SGVsbG8=", // "Hello"
			expectedBytes: []byte("Hello"),
			expectError:   false,
		},
		{
			name:          "Valid Standard Base64 - Padding Added",
			input:         "SGVsbG8", // "Hello" without padding
			expectedBytes: []byte("Hello"),
			expectError:   false,
		},
		{
			name:          "Valid Standard Base64 - Longer String",
			input:         "VGhpcyBpcyBhIHRlc3Qgc3RyaW5n", // "This is a test string" without padding
			expectedBytes: []byte("This is a test string"),
			expectError:   false,
		},
		{
			name:          "Empty String",
			input:         "",
			expectedBytes: []byte(""),
			expectError:   false,
		},
		{
			name:          "Invalid Base64 Character",
			input:         "SGVsbG8!", // Contains invalid '!'
			expectedBytes: []byte(""),
			expectError:   true,
			errorMsg:      "illegal base64 data at input byte",
		},
		{
			name:          "String requiring 1 padding char",
			input:         "YWI", // "ab" -> "YWI="
			expectedBytes: []byte("ab"),
			expectError:   false,
		},
		{
			name:          "String requiring 2 padding chars",
			input:         "YQ", // "a" -> "YQ=="
			expectedBytes: []byte("a"),
			expectError:   false,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			decoded, err := JwtDecodeSegment(tc.input)

			if tc.expectError {
				assert.Error(t, err)
				assert.Equal(t, tc.expectedBytes, decoded) // Should return empty bytes on error
				if tc.errorMsg != "" {
					assert.ErrorContains(t, err, tc.errorMsg)
				}
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tc.expectedBytes, decoded)
			}
		})
	}
}

func TestJwtUrlDecodeSegment(t *testing.T) {
	tests := []struct {
		name          string
		input         string
		expectedBytes []byte
		expectError   bool
		errorMsg      string
	}{
		{
			name:          "Valid URL Base64 - No Padding Needed",
			input:         "SGVsbG8", // "Hello" (URL encoding often omits padding)
			expectedBytes: []byte("Hello"),
			expectError:   false,
		},
		{
			name:          "Valid URL Base64 - With Standard Chars",
			input:         "VGhpcyBpcyBhIHRlc3Qgc3RyaW5n", // "This is a test string"
			expectedBytes: []byte("This is a test string"),
			expectError:   false,
		},
		{
			name:          "Empty String",
			input:         "",
			expectedBytes: []byte(""),
			expectError:   false,
		},
		{
			name:          "Invalid URL Base64 Character (+)", // '+' is standard, not URL safe without encoding
			input:         "SGVsbG8+",
			expectedBytes: []byte(""),
			expectError:   true,
			errorMsg:      "illegal base64 data at input byte",
		},
		{
			name:          "Invalid URL Base64 Character (/)", // '/' is standard, not URL safe without encoding
			input:         "SGVsbG8/",
			expectedBytes: []byte(""),
			expectError:   true,
			errorMsg:      "illegal base64 data at input byte",
		},
		{
			name:          "String requiring 1 padding char",
			input:         "YWI", // "ab" -> "YWI="
			expectedBytes: []byte("ab"),
			expectError:   false,
		},
		{
			name:          "String requiring 2 padding chars",
			input:         "YQ", // "a" -> "YQ=="
			expectedBytes: []byte("a"),
			expectError:   false,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// First, ensure the input *could* be generated by URLEncoding for valid cases
			if !tc.expectError {
				// Re-encode expected bytes to see if input is a valid (potentially unpadded) URL encoding
				expectedEncoded := base64.URLEncoding.EncodeToString(tc.expectedBytes)
				// Allow input if it's the fully padded version or the unpadded version
				assert.Contains(t, []string{expectedEncoded, expectedEncoded[:len(expectedEncoded)-len("=")*((4-len(tc.input)%4)%4)]}, tc.input, "Test input setup issue: input doesn't match URL encoding of expected bytes")
			}

			decoded, err := JwtUrlDecodeSegment(tc.input)

			if tc.expectError {
				assert.Error(t, err)
				assert.Equal(t, tc.expectedBytes, decoded) // Should return empty bytes on error
				if tc.errorMsg != "" {
					assert.ErrorContains(t, err, tc.errorMsg)
				}
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tc.expectedBytes, decoded)
			}
		})
	}
}
